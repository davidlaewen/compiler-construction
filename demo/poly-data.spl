// Polymorphic ADT examples

data Maybe<a> {
  None(), Some(some : a)
}

data Either<a,b> {
  Left(left : a), Right(right : b)
}

data List<a> {
  Nil(), Cons(head : a, tail : List<a>)
}

data Pair<a,b> {
  MkPair(lpair : a, rpair : b)
}

data Tree<a> {
  Leaf(), Node(label : a, ltree : Tree<a>, rtree : Tree<a>)
}


Tree<Bool> treeBool = Node(True, Node(False, Leaf(), Node(False, Leaf(), Leaf())),
                          Node(True, Leaf(), Leaf()));
/*      True
       /    \
    False   True
    /   \   /  \
      False
       / \          */

Tree<Int> treeInt = Node(1, Node(2, Leaf(), Leaf()),
                      Node(3, Leaf(), Node(4, Leaf(), Leaf())));
/*      1
       / \
      2   3
     / \ / \
            4   */


main() {
  printLn(fromMaybe(0,None())); // Should be `0`
  printLn(fromMaybe(0,Some(42))); // Should be `42`

  printLn(depth(treeBool)); // Should be `3`
  printLn(exists(treeBool)); // Should be `True`
  printLn(forall(treeBool)); // Should be `False`

  printLn(depth(treeInt)); // Should be `3`
  printLn(sumTree(treeInt)); // Should be `10`
  printList(treeToList(treeInt)); // Should be `1:2:3:4:[]`

  return;
}



fromMaybe(default,m) :: a Maybe<a> -> a {
  if (isNone(m)) {
    return default;
  } else {
    return m.some;
  }
}

depth(t) :: Tree<a> -> Int {
  if (isLeaf(t)) {
    return 0;
  } else {
    return 1 + max(depth(t.ltree), depth(t.rtree));
  }
}

treeToList(t) :: Tree<a> -> List<a> {
  if (isLeaf(t)) {
    return Nil();
  } else {
    return Cons(t.label, append(treeToList(t.ltree), treeToList(t.rtree)));
  }
}

exists(t) :: Tree<Bool> -> Bool {
  if (isLeaf(t)) {
    return False;
  } else {
    return t.label || exists(t.ltree) || exists(t.rtree);
  }
}

forall(t) :: Tree<Bool> -> Bool {
  if (isLeaf(t)) {
    return False;
  } else {
    return t.label && forall(t.ltree) && forall(t.rtree);
  }
}

sumTree(t) :: Tree<Int> -> Int {
  if (isLeaf(t)) {
    return 0;
  } else {
    return t.label + sumTree(t.ltree) + sumTree(t.rtree);
  }
}

// Helper functions

append(l1,l2) :: List<a> List<a> -> List<a> {
  if (isNil(l1)) {
    return l2;
  } else {
    return Cons(l1.head, append(l1.tail, l2));
  }
}

max(n,m) {
  if (n > m) { return n; } else { return m; }
}

printList(l) {
  if (isNil(l)) {
    print('[');
    print(']');
  } else {
    print(l.head);
    print(':');
    printList(l.tail);
  }
  return;
}
