\documentclass[dvipsnames,aspectratio=169]{beamer}

\usefonttheme{professionalfonts}%% do not define math settings by beamer itself
\usepackage[T1]{fontenc}
\usepackage[libertine]{newtxmath}
\usepackage[tt=false]{libertine}
\usepackage[varqu,varl,scale=0.9]{zi4}
\usepackage{sfmath}

\usepackage[utf8]{inputenc} % oder was auch immer
\usepackage[british]{babel} % oder was auch immer
% Oder was auch immer. Zu beachten ist, das Font und Encoding passen
% müssen. Falls T1 nicht funktioniert, kann man versuchen, die Zeile
% mit fontenc zu löschen.

% Load packages
\input{packages.tex}
\input{commands.tex}

\setlength{\parskip}{\baselineskip}

\mode<presentation>
{
    \usetheme{Madrid}
    \useinnertheme{rectangles}
    \useoutertheme{infolines}
    \usecolortheme{whale}

    \setbeamertemplate{navigation symbols}{}

    \setbeamercovered{invisible} % Visibility of covered items

    % Margins
    \setbeamersize{
        text margin left=6mm,
        text margin right=6mm
    }
}


\title[Phase 3 -- Code Generation]% (optional, nur bei langen Titeln nötig)
{Phase 3 -- Code Generation}

\subtitle
{}

\author% (optional, nur bei vielen Autoren)
{David Läwen}

\institute[]% (optional, aber oft nötig)
{Compiler Construction}

\date[May 8th, 2025] % (optional, sollte der abgekürzte Konferenzname sein)
{May 8th, 2025}

\subject{SPL Compiler Code Generation Phase}
% Dies wird lediglich in den PDF Informationskatalog eingefügt. Kann gut
% weggelassen werden.


% Falls eine Logodatei namens "university-logo-filename.xxx" vorhanden
% ist, wobei xxx ein von latex bzw. pdflatex lesbares Graphikformat
% ist, so kann man wie folgt ein Logo einfügen:
% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}


\begin{document}

% TITLE PAGE
\begin{frame}
  \titlepage
\end{frame}

% INTRODUCTION
\begin{frame}{General Setup}

  \begin{minipage}{.6\textwidth}

    \begin{itemize}
      \item Implementation language: Haskell
      \item AST represented as \emph{rose tree} consisting of algebraic data
            types and lists
      \item Typing stage produces a \emph{typed} AST, annotated with the
            inferred/checked types
    \end{itemize}

  \end{minipage}\hfill
  \begin{minipage}{.3\textwidth}
    \includegraphics[scale=.17]{assets/haskell-icon.pdf}
  \end{minipage}

\end{frame}


% \begin{frame}[fragile]{Desugaring}

% \begin{minted}{haskell}
% desugar :: P.Program -> T.Program ()
% \end{minted}

% \begin{itemize}
%   \item First step: Desugar parse AST to type checking AST
%   \item Desugar operations and selectors to function calls
%   \item Allows uniform treatment as ordinary function calls
% \end{itemize}

% \end{frame}


\begin{frame}[fragile]{Output of Type Checking Phase}

  \begin{minted}{haskell}
data Program varTy funTy = Program [VarDecl varTy] [FunMutDecl varTy funTy]

data VarDecl a = VarDecl Loc (Maybe UType) T.Text (Expr a) a
data FunMutDecl a b = MutualDecls Loc [FunDecl a b] | SingleDecl (FunDecl a b)
data FunDecl a b =
  FunDecl Loc T.Text [T.Text] (Maybe UType) [VarDecl a] [Stmt a] b

data Stmt a = Assign Loc VarLookup a (Expr a) | FunCall Loc FunName [Expr a] | ...

data VarLookup = VarId Loc T.Text | VarField Loc VarLookup Field

data Expr a = Ident Loc T.Text a | ... | FunCallE Loc FunName [Expr a] a
\end{minted}

\end{frame}

% Things to mention in the presentation:
% - Show & briefly explain Register and Instr data types
% - Show & explain the CodeGen monad, as well as the map/state for global and
%   local identifiers (variable and argument locations)
% - Discuss assignments with field selectors on the left, e.g.
%   x.fst.hd.snd.tl = 42;
%   and how to deal with these
% - Pass-by-value vs pass-by-reference, reuse examples from report
% - Interaction of recursive lists with mutability, e.g. in
%   var l = 1:[];
%   l.tl = l;


\begin{frame}[fragile]{Output of Type Checking Phase}

  Function calls are represented using \mintinline{haskell}|FunName|:

  \begin{minted}{haskell}
  data FunName = Name T.Text
    | Not | Neg | Add | Sub | Mul | Div | Mod | ... | Cons | IsEmpty
    | HeadFun | TailFun | FstFun | SndFun
    | Print
  \end{minted}

  \begin{itemize}
    \item Either a user-defined function, a built-in operator, a field selector,
          or \texttt{print}
    \item Allows uniform treatment of all the above, where the signature of
          built-ins is hard-coded, and the signature of user functions is found
          in the typed AST.
  \end{itemize}

\end{frame}


% REGISTERS & INSTRUCTIONS

\begin{frame}[fragile]{Registers \& Instructions}

  \begin{minted}{haskell}
data Register = ProgCounter | StackPointer | MarkPointer | HeapPointer
              | RetReg | HeapLowReg | Scratch2 | Scratch3

data Instr = Label T.Text | Ret | Halt | Link Int | Unlink | Adjust Int
  | LoadReg Register | StoreReg Register
  | ...
  | NegOp | AddOp | SubOp | MulOp | DivOp | ModOp
  | TrapInt | TrapChar

instance Show Instr where
  show (Label t) = T.unpack t <> ":"
  show Ret = tab <> "ret"
  show Halt = tab <> "halt"
  show (Link i) = tab <> "link" <+> show i
  ...
\end{minted}

\end{frame}


% CODE GEN MONAD

\begin{frame}[fragile]{Code Generation Monad}

\begin{minted}{haskell}
type LocationMap = M.Map T.Text Int

data CodegenState = CodegenState {
  labelCounter :: Int,
  offsets :: LocationMap,
  heapLocs :: LocationMap
}

type Codegen = State CodegenState

runCodegen :: Codegen a -> a
runCodegen = flip evalState (CodegenState 0 M.empty M.empty)
\end{minted}

\begin{itemize}
  \item State monad allows incrementing label counter for unique label names,
        and resetting \mintinline{haskell}|offsets| map for arguments and local variables
\end{itemize}

\end{frame}


\begin{frame}[fragile]{Statement Code Gen Example}

  \begin{itemize}
    \item Example of code generation for \texttt{while} statement
  \end{itemize}

\begin{minted}{haskell}
codegenStmt :: Stmt UType -> Codegen [Instr]

codegenStmt (While _ cond loopStmts) = do
  condProgram <- codegenExpr cond
  loopProgram <- concatMapM codegenStmt loopStmts
  topLabel <- freshLabel "while"
  endLabel <- freshLabel "endwhile"
  pure $
    [Label topLabel] ++ condProgram ++ [BranchFalse endLabel]
    ++ loopProgram ++ [BranchAlways topLabel]
    ++ [Label endLabel]
\end{minted}

\end{frame}


\begin{frame}[fragile]{Multi-Register Types}
  \begin{itemize}
    \item Instances of \texttt{Int}, \texttt{Bool} and \texttt{Char} stored in
          one register
    \item For e.g. \texttt{[Int]}, the size of a value can be arbitrarily large
    \item Use linked list representation, storing segments on the heap, e.g.
  \end{itemize}\vspace{-6mm}

  \[ \texttt{[Int] l = 1:2:3:[];} \]

  \begin{table}[]
    \begin{tabular}{>{\ttfamily}l| >{\ttfamily}l|l}
      \textbf{\textsf{Address}} & \textbf{\textsf{Value}} & \textbf{Structure} \\
      \hline
      0x0007D0 & 0x000003 & begin \\
      0x0007D1 & 0xF0F0F0F0 & end \\
      \hline
      0X0007D2 & 0X000002 & begin \\
      0X0007D3 & 0X0007D1 & end \\
      \hline
      0X0007D4 & 0X000001 & begin \\
      0X0007D5 & 0X0007D3 & end
    \end{tabular}
  \end{table}

\end{frame}


\begin{frame}[fragile]{Pass-by-Value vs Pass-by-Reference}

  \begin{itemize}
    \item Single-register types (\texttt{Int}, \texttt{Char}, \texttt{Bool})
          passed to functions as value itself
    \item Multi-register types (tuples and lists) passed as heap address
          in a single register
  \end{itemize}

\begin{lstlisting}[language=spl]
  f(x) :: Int -> Int {
    (Int,Bool) t = (x,True);
    g(t);
    return t.fst;
  }

  g(t) :: (Int,a) -> Void {
    t.fst = t.fst + 1;
    return;
  }
\end{lstlisting}\vspace{-6mm}
%
\begin{itemize}
  \item Interaction with polymorphism: \emph{Monomorphisation} vs \emph{boxing}
\end{itemize}

\end{frame}


\begin{frame}[fragile]{Monomorphisation vs Boxing}

  Two ways to deal with polymorphic functions:
  \begin{itemize}
    \item Generate monomorphic instances
    \item Use \emph{boxing} on multi-register data (e.g. tuples)
  \end{itemize}

Example:

\begin{lstlisting}[language=spl]
  renest(t) :: ((a,b),c) -> (a,(b,c)) {
    var t1 = t.fst;
    return (t1.fst, (t1.snd, t.snd));
  }
\end{lstlisting}\vspace{-4mm}

\begin{itemize}
  \item Monomorphisation: For just \texttt{Int}, \texttt{Bool} and
        \texttt{Char}, we could get up to 27 combinations
  \item Boxing: One instance only, but with small performance
        cost and use of heap memory
\end{itemize}

\end{frame}

% \begin{frame}{Limitations of Hindley-Milner}

%   Classic Hindley-Milner:
%   \begin{itemize}
%     \item Traverse AST
%     \item Solve constraints immediately upon encountering them
%     \item Accumulate substitution
%   \end{itemize}

%   Limitation: Constraints must be solved in the order they are encountered in

% \end{frame}


% \begin{frame}{``French-style'' Type Inference (Pottier \& Rémy)}

%   Type inference in GHC:
%   \begin{itemize}
%     \item Traverse AST, generate constraint set and \emph{elaborated} AST with
%           metavariable annotations
%     \item Solve the constraint set
%     \item Resulting substitution is applied to the elaborated AST (``\emph{zonking}'')
%     \item Due to François Pottier and Didier Rémy~\footfullcite{PottierRemy2005}
%   \end{itemize}

% \end{frame}


% \begin{frame}[fragile]{Type Checker Monad}

%   \begin{minted}{haskell}
%   type Environment = M.Map Id UType

%   data CGenState = CGenState{ env :: Environment, nextUVar :: Int }

%   type CGen a = (StateT CGenState (Except T.Text)) a

%   data UType = Int | ... | List UType | Fun [UType] UType
%              | UVar Int
%   \end{minted}

% \end{frame}


% \begin{frame}[fragile]{Type Checker Monad}

%   \begin{minted}{haskell}
%   type Environment = M.Map Id UType

%   data CGenState = CGenState{ env :: Environment, nextUVar :: Int }

%   type CGen a = (StateT CGenState (Except T.Text)) a
%   \end{minted}

%   Why \mintinline{haskell}|StateT|? \vspace*{-4mm}
%   \begin{itemize}
%     \item Consider the \mintinline{haskell}|Program| node:
%     \begin{minted}{haskell}
%   data Program a = Program [VarDecl a] [FunDecl a]
%   \end{minted}
%     \item Bindings from first list are used in second list
%     \item Allows restoring environment after checking function body
%   \end{itemize}

% \end{frame}



\end{document}
