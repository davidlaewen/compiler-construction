\documentclass[dvipsnames,aspectratio=169]{beamer}

\usefonttheme{professionalfonts}%% do not define math settings by beamer itself
\usepackage[T1]{fontenc}
\usepackage[libertine]{newtxmath}
\usepackage[tt=false]{libertine}
\usepackage[varqu]{zi4}
\usepackage{sfmath}

\usepackage[utf8]{inputenc} % oder was auch immer
\usepackage[british]{babel} % oder was auch immer
% Oder was auch immer. Zu beachten ist, das Font und Encoding passen
% müssen. Falls T1 nicht funktioniert, kann man versuchen, die Zeile
% mit fontenc zu löschen.

% Load packages
\input{packages.tex}
\input{commands.tex}

\setlength{\parskip}{\baselineskip}

\mode<presentation>
{
    \usetheme{Madrid}
    \useinnertheme{rectangles}
    \useoutertheme{infolines}
    \usecolortheme{whale}

    \setbeamertemplate{navigation symbols}{}

    \setbeamercovered{invisible} % Visibility of covered items

    % Margins
    \setbeamersize{
        text margin left=6mm,
        text margin right=6mm
    }
}


\title[Phase 2 -- Semantic Analyses]% (optional, nur bei langen Titeln nötig)
{Phase 2 -- Semantic Analyses}

\subtitle
{}

\author% (optional, nur bei vielen Autoren)
{Simcha van Collem \& David Läwen}

\institute[]% (optional, aber oft nötig)
{Compiler Construction}

\date[April 11th, 2023] % (optional, sollte der abgekürzte Konferenzname sein)
{April 11th, 2023}

\subject{Later Credits}
% Dies wird lediglich in den PDF Informationskatalog eingefügt. Kann gut
% weggelassen werden.


% Falls eine Logodatei namens "university-logo-filename.xxx" vorhanden
% ist, wobei xxx ein von latex bzw. pdflatex lesbares Graphikformat
% ist, so kann man wie folgt ein Logo einfügen:
% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}


\begin{document}

% TITLE PAGE
\begin{frame}
  \titlepage
\end{frame}

% INTRODUCTION
\begin{frame}{General Information}

  \begin{minipage}{.6\textwidth}

    \begin{itemize}
      \item Implementation language: Haskell
      \item Other general info?
      \item AST represented as \emph{rose tree} consisting of algebraic data
            types and lists
      \item Type checking proceeds by traversing the AST structure
    \end{itemize}

  \end{minipage}\hfill
  \begin{minipage}{.3\textwidth}
    \includegraphics[scale=.17]{assets/haskell-icon.pdf}
  \end{minipage}

\end{frame}


\begin{frame}[fragile]{Type Checking AST}

  \emph{AST structure -- how do we traverse the nodes?
  Purpose of type parameter `a'?}
  %
  \begin{minted}{haskell}
data Program a = Program [VarDecl a] [FunDecl a]

data VarDecl a = VarDecl (Maybe UType) T.Text (Expr a) a

data FunDecl a = FunDecl T.Text [T.Text] (Maybe UType) [VarDecl a] [Stmt a] a

data Stmt a = If (Expr a) [Stmt a] [Stmt a]
            | While (Expr a) [Stmt a]
            | Assign VarLookup (Expr a)
            | FunCall FunName [Expr a]
            | Return (Maybe (Expr a))

data VarLookup = VarId T.Text | VarField VarLookup Field

\end{minted}

\end{frame}


\begin{frame}[fragile]{Type Checking AST}

  \begin{minted}{haskell}
  data Expr a = Ident T.Text a
              | Int Integer a
              | Char Char a
              | Bool Bool a
              | FunCallE FunName [Expr a] a
              | EmptyList a
              | Tuple (Expr a) (Expr a) a
  \end{minted}

  Wait, where did the unary and binary operations go?\vspace*{-2mm}
  %
  \begin{itemize}
    \item Desugared to (pre-defined) functions
    \item Allows uniform treatment as ordinary function calls
  \end{itemize}


\end{frame}


\begin{frame}[fragile]{Unification Types}

  \begin{minted}{haskell}
  data UType = Int | Bool | Char | Void
             | Prod UType UType | List UType
             | Fun [UType] UType
             | UVar UVar
             | TVar TVar
  \end{minted}

\end{frame}


\begin{frame}{Hindley-Milner Type Inference}

  \begin{itemize}
    \item Discuss one vs. two step approach
    \item Reference Pottier \& Rémy
    \item Pros and cons of both approaches?
    \item Motivate choice?
  \end{itemize}

\end{frame}


\begin{frame}{Hindley-Milner vs. ``French-style'' Type Inference}

  Classic Hindley-Milner:
  \begin{itemize}
    \item Traverse AST
    \item Solve constraints immediately upon encountering them
    \item Accumulate substitution
  \end{itemize}

  Limitation: Constraints must be solved in the order they are encountered in

\end{frame}


\begin{frame}{``French-style'' Type Inference (Pottier \& Rémy)}

  Type inference in GHC (attributed to François Pottier and Didier Rémy):
  \begin{itemize}
    \item Traverse AST, generate constraint set and \emph{elaborated} AST with
          metavariable annotations
    \item Solve the constraint set
    \item Resulting substitution is applied to the elaborated AST (``\emph{zonking}'')
  \end{itemize}

\end{frame}


\begin{frame}{Type Checker Design}

  \begin{itemize}
    \item Design decisions
    \item Outline general setup
  \end{itemize}

\end{frame}


\begin{frame}[fragile]{Type Checker Monad}

  \begin{minted}{haskell}
  type Environment = M.Map Id UType

  data CGenState = CGenState{ env :: Environment, varState :: VarState }

  type CGen a = (StateT CGenState (Except T.Text)) a
  \end{minted}

  \emph{Mention ``storing'' and restoring of the environment state in `checkFunDecl'
  here}

\end{frame}


\begin{frame}{Typing Expressions}

  \begin{itemize}
    \item Selection of typing rules for expressions
  \end{itemize}

  \begin{mathpar}
    \inferrule[T-Bool]%
    { b \in \{ \True, \False \} }%
    { \Gamma \turnstile b : \Bool }
    \and
    \inferrule[T-Int]%
    { n \in \mathbb{Z} }%
    { \Gamma \turnstile n : \Int }
    \\
    \inferrule[T-And]%
    { \Gamma \turnstile e_1 : \Bool \quad \Gamma \turnstile e_2 : \Bool }%
    { \Gamma \turnstile e_1\ \texttt{\&\&}\ e_2 : \Bool }
    \and
    \inferrule[T-Plus]%
    { \Gamma \turnstile e_1 : \Int \quad\quad \Gamma \turnstile e_2 : \Int }%
    { \Gamma \turnstile e_1\ \texttt{+}\ e_2 : \Int }
  \end{mathpar}

\end{frame}


\begin{frame}{Typing Expressions}

  \begin{itemize}
    \item Typing field accesses and function types
  \end{itemize}

  \begin{mathpar}
    \inferrule[T-Fst]%
    { \Gamma \turnstile p : (\tau,\sigma) }%
    { \Gamma \turnstile p.\fst : \tau }
    \and
    \inferrule[T-Head]%
    { \Gamma \turnstile l : [\tau] }%
    { \Gamma \turnstile l.\head : \tau }
    \\
    \inferrule[T-FunCall]%
    { \Gamma \turnstile e_1 : \tau_1 \quad \dots \quad \Gamma \turnstile e_n : \tau_n
      \quad\quad f : \tau_1 \dots \tau_n \to \sigma }%
    { \Gamma \turnstile f(e_1, \dots, e_n) : \sigma }
  \end{mathpar}

  \[ \textsf{cons} : \forall \alpha.\ \alpha\ [\alpha] \to [\alpha] \]
  \[ \textsf{isEmpty} : \forall \alpha.\ [\alpha] \to \Bool \]

\end{frame}


\begin{frame}{Typing Statements}

  \begin{itemize}
    \item Variable assignments (environment modification)
    \item If-Else, While, etc. -- Typing rules
  \end{itemize}

\end{frame}




% XYZ
\section{Type Checking}

% TABLE OF CONTENTS I
\begin{frame}{Contents}
  \hspace*{0.3cm}
  \begin{minipage}[c][4cm]{\textwidth}
      \only<1>{\tableofcontents}
      \only<2>{\tableofcontents[currentsection]}
  \end{minipage}
\end{frame}








\section<presentation*>{References}

\begin{frame}{References}
  \nocite{*}
  \AtNextBibliography{\small}
  \printbibliography
\end{frame}

\end{document}
