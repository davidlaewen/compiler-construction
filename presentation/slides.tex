\documentclass[dvipsnames,aspectratio=169]{beamer}

\usefonttheme{professionalfonts}%% do not define math settings by beamer itself
\usepackage[T1]{fontenc}
\usepackage[libertine]{newtxmath}
\usepackage[tt=false]{libertine}
\usepackage[varqu]{zi4}
\usepackage{sfmath}

\usepackage[utf8]{inputenc} % oder was auch immer
\usepackage[british]{babel} % oder was auch immer
% Oder was auch immer. Zu beachten ist, das Font und Encoding passen
% müssen. Falls T1 nicht funktioniert, kann man versuchen, die Zeile
% mit fontenc zu löschen.

% Load packages
\input{packages.tex}
\input{commands.tex}

\setlength{\parskip}{\baselineskip}

\mode<presentation>
{
    \usetheme{Madrid}
    \useinnertheme{rectangles}
    \useoutertheme{infolines}
    \usecolortheme{whale}

    \setbeamertemplate{navigation symbols}{}

    \setbeamercovered{invisible} % Visibility of covered items

    % Margins
    \setbeamersize{
        text margin left=6mm,
        text margin right=6mm
    }
}


\title[Phase 2 -- Semantic Analyses]% (optional, nur bei langen Titeln nötig)
{Phase 2 -- Semantic Analyses}

\subtitle
{}

\author% (optional, nur bei vielen Autoren)
{Simcha van Collem \& David Läwen}

\institute[]% (optional, aber oft nötig)
{Compiler Construction}

\date[April 11th, 2023] % (optional, sollte der abgekürzte Konferenzname sein)
{April 11th, 2023}

\subject{Later Credits}
% Dies wird lediglich in den PDF Informationskatalog eingefügt. Kann gut
% weggelassen werden.


% Falls eine Logodatei namens "university-logo-filename.xxx" vorhanden
% ist, wobei xxx ein von latex bzw. pdflatex lesbares Graphikformat
% ist, so kann man wie folgt ein Logo einfügen:
% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}


\begin{document}

% TITLE PAGE
\begin{frame}
  \titlepage
\end{frame}

% INTRODUCTION
\begin{frame}{General Information}

  \begin{minipage}{.6\textwidth}

    \begin{itemize}
      \item Implementation language: Haskell
      \item AST represented as \emph{rose tree} consisting of algebraic data
            types and lists
      \item Type checking proceeds by traversing the AST structure
    \end{itemize}

  \end{minipage}\hfill
  \begin{minipage}{.3\textwidth}
    \includegraphics[scale=.17]{assets/haskell-icon.pdf}
  \end{minipage}

\end{frame}


\begin{frame}[fragile]{Desugaring}

\begin{minted}{haskell}
desugar :: P.Program -> T.Program ()
\end{minted}

\begin{itemize}
  \item First step: Desugar parse AST to type checking AST
  \item Desugar operations and selectors to function calls
  \item Allows uniform treatment as ordinary function calls
\end{itemize}

\end{frame}


\begin{frame}[fragile]{Type Checking AST}

  \begin{minted}{haskell}
data Program a = Program [VarDecl a] [FunDecl a]

data VarDecl a = VarDecl (Maybe UType) T.Text (Expr a) a

data FunDecl a = FunDecl T.Text [T.Text] (Maybe UType) [VarDecl a] [Stmt a] a

data Stmt a = Assign VarLookup (Expr a)
            | FunCall FunName [Expr a]
            | ...

data VarLookup = VarId T.Text | VarField VarLookup Field

data Expr a = FunCallE FunName [Expr a] a
            | ...
\end{minted}

\end{frame}


\begin{frame}{Limitations of Hindley-Milner}

  Classic Hindley-Milner:
  \begin{itemize}
    \item Traverse AST
    \item Solve constraints immediately upon encountering them
    \item Accumulate substitution
  \end{itemize}

  Limitation: Constraints must be solved in the order they are encountered in

\end{frame}


\begin{frame}{``French-style'' Type Inference (Pottier \& Rémy)}

  Type inference in GHC:
  \begin{itemize}
    \item Traverse AST, generate constraint set and \emph{elaborated} AST with
          metavariable annotations
    \item Solve the constraint set
    \item Resulting substitution is applied to the elaborated AST (``\emph{zonking}'')
    \item Due to François Pottier and Didier Rémy~\footfullcite{PottierRemy2005}
  \end{itemize}

\end{frame}


\begin{frame}[fragile]{Type Checker Monad}

  \begin{minted}{haskell}
  type Environment = M.Map Id UType

  data CGenState = CGenState{ env :: Environment, nextUVar :: Int }

  type CGen a = (StateT CGenState (Except T.Text)) a

  data UType = Int | ... | List UType | Fun [UType] UType
             | UVar Int
  \end{minted}

\end{frame}


\begin{frame}[fragile]{Type Checker Monad}

  \begin{minted}{haskell}
  type Environment = M.Map Id UType

  data CGenState = CGenState{ env :: Environment, nextUVar :: Int }

  type CGen a = (StateT CGenState (Except T.Text)) a
  \end{minted}

  Why \mintinline{haskell}|StateT|? \vspace*{-4mm}
  \begin{itemize}
    \item Consider the \mintinline{haskell}|Program| node:
    \begin{minted}{haskell}
  data Program a = Program [VarDecl a] [FunDecl a]
  \end{minted}
    \item Bindings from first list are used in second list
    \item Allows restoring environment after checking function body
  \end{itemize}

\end{frame}





\section<presentation*>{References}

\begin{frame}{References}
  \nocite{*}
  \AtNextBibliography{\small}
  \printbibliography
\end{frame}

\end{document}
