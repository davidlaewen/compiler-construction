\documentclass{report}

\input{packages.tex}
\input{macros.tex}

\author{%
	David~L\"awen\\
	\small\texttt{s1105105}\and
	Simcha~van~Collem\\
	\small\texttt{s1040283}
}
\date{\today}
\title{SPL compiler}

\begin{document}

\maketitle%

\tableofcontents%

\chapter{Introduction}
\begin{quote}
	\it
	This document is a mandatory skeleton for your report.
	It gives by no means an exhaustive list of suggestions for content.
	The report should be readable self-contained and readable without access to the source code.
\end{quote}
\begin{itemize}
	\item Motivate your language choice
	\item Introduce spl
	\item Give some nice examples.
	\item \ldots
\end{itemize}

\section{Language Choice}
For our compiler, we chose Haskell as our implementation language. Our choice
of Haskell was motivated in part by our prior experience working with Haskell,
we both took the Bachelor's course ``Functional Programming'', which also covers
monadic parser combinators as we use in our implementation.
Beyond the course on Haskell, ...

The approach of writing lexers and parsers using monadic function and
combinators is elegant and allows one to work at a high level abstraction.
In particular, the parser functions closely correspond to the rules of the
parser grammar that they express. This makes the parser and its constituent
parts easier to reason about.

For representing and manipulating abstract syntax trees, the algebraic data
types are also an obvious choice. Recursive functions over ADTs representing
AST variants as well as higher-order operations such as \emph{mapping} and
\emph{folding} allow many operators on ASTs to be expressed concisely.


\chapter{Lexing \& Parsing}
\input{content/lexing-parsing.tex}

\chapter{Analyses \& Typing}
\begin{itemize}
	\item New Abstract Syntax Tree? Decorate existing Abstract Syntax Tree?
	\item Error messages?
	\item Polymorphism? Inference? Overloading?
	\item Problems?
	\item\ldots
\end{itemize}

\chapter{Code Generation}
\begin{itemize}
	\item Compilation scheme?
	\item How is data represented? Lists tuples
	\item Semantics style, call-by-reference, call-by-value?
	\item How did you solve overloaded functions?
	\item Polymorphism?
	\item Printing?
	\item Problems?
	\item\ldots
\end{itemize}

\chapter{Extension}
Describe your extension in detail

\chapter{Conclusion}
What does work, what does not etc.

\section{Reflection}
\begin{itemize}
	\item What do you think of the project?
	\item How did it work out?
	\item How did you divide the work?
	\item Pitfalls?
	\item \ldots
\end{itemize}

\appendix
\chapter{Grammar}
Change the grammar to the one you actually used

\begin{verbatim}
SPL       = Decl+
Decl      = VarDecl
          | FunDecl
VarDecl   = ('var' | Type) id  '=' Exp ';'
FunDecl   = id '(' [ FArgs ] ')' [ '::' FunType ] '{' VarDecl* Stmt+ '}'
RetType   = Type
          | 'Void'
FunType   = [ FTypes ] '->' RetType
FTypes    = Type [ FTypes ]
Type      = BasicType
          | '(' Type ',' Type ')'
          | '[' Type ']'
          | id
BasicType = 'Int'
          | 'Bool'
          | 'Char'
FArgs     = [ FArgs ',' ] id
Stmt      = 'if' '(' Exp ')' '{' Stmt* '}' [ 'else' '{' Stmt* '}' ]
          | 'while' '(' Exp ')' '{' Stmt* '}'
          | id Field '=' Exp ';'
          | FunCall ';'
          | 'return' [ Exp ] ';'
Exp       = id Field
          | Exp Op2 Exp
          | Op1 Exp
          | int
          | char
          | 'False' | 'True'
          | '(' Exp ')'
          | FunCall
          | '[]'
          | '(' Exp ',' Exp ')'
Field     = [ Field ( '.' 'hd' | '.' 'tl' | '.' 'fst' | '.' 'snd' ) ]
FunCall   = id '(' [ ActArgs ] ')'
ActArgs   = Exp [ ',' ActArgs ]
Op2       = '+'  | '-' | '*' | '/'  | '%'
          | '==' | '<' | '>' | '<=' | '>=' | '!='
          | '&&' | '||'
          | ':'
Op1       = '!'  | '-'
int       = [ '-' ] digit+
id        = alpha ( '_' | alphaNum)*
\end{verbatim}

\end{document}
