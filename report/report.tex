\documentclass[dvipsnames]{report}

\usepackage[T1]{fontenc}

\input{packages.tex}
\input{macros.tex}

\author{%
	David~L\"awen\\
	\small\texttt{s1105105}
}
\date{June 8, 2025}
\title{SPL Compiler}

\setcounter{tocdepth}{1}

\begin{document}

\maketitle%

\tableofcontents%

% \begin{quote}
% 	\it
% 	This document is a mandatory skeleton for your report.
% 	It gives by no means an exhaustive list of suggestions for content.
% 	The report should be readable self-contained and readable without access to the source code.
% \end{quote}

\input{content/introduction.tex}

\input{content/lexing-parsing.tex}

\input{content/semantic-analyses.tex}

\input{content/code-generation.tex}

\input{content/extension.tex}

\input{content/conclusion.tex}

% BIBLIOGRAPHY
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{references.bib}

\appendix
\chapter{Grammar} \label{chp:grammar}

We used the following grammar:

\begin{verbatim}
SPL       = VarDecl* FunDecl+
VarDecl   = ('var' | Type) id  '=' Exp ';'
FunDecl   = id '(' [ FArgs ] ')' [ '::' FunType ] '{' VarDecl* Stmt+ '}'
RetType   = Type
          | 'Void'
FunType   = [ FTypes ] '->' RetType
FTypes    = Type [ FTypes ]
Type      = BasicType
          | '(' Type ',' Type ')'
          | '[' Type ']'
          | id
BasicType = 'Int'
          | 'Bool'
          | 'Char'
FArgs     = [ FArgs ',' ] id
Stmt      = 'if' '(' Exp ')' '{' Stmt* '}' [ 'else' '{' Stmt* '}' ]
          | 'while' '(' Exp ')' '{' Stmt* '}'
          | id Field '=' Exp ';'
          | FunCall ';'
          | 'return' [ Exp ] ';'
Exp       = id Field
          | Exp Op2 Exp
          | Op1 Exp
          | int
          | char
          | 'False' | 'True'
          | '(' Exp ')'
          | FunCall
          | '[]'
          | '(' Exp ',' Exp ')'
Field     = [ Field ( '.' 'hd' | '.' 'tl' | '.' 'fst' | '.' 'snd' ) ]
FunCall   = id '(' [ ActArgs ] ')'
ActArgs   = Exp [ ',' ActArgs ]
Op2       = '+'  | '-' | '*' | '/'  | '%'
          | '==' | '<' | '>' | '<=' | '>=' | '!='
          | '&&' | '||'
          | ':'
Op1       = '!'  | '-'
int       = [ '-' ] digit+
id        = alpha ( '_' | alphaNum)*
\end{verbatim}


\chapter{Extended Grammar}

With our extension, which we discuss in \cref{chp:extension}, the updated grammar becomes:

\begin{verbatim}
SPL       = DataDecl* VarDecl* FunDecl+
DataDecl  = 'data' '{' [ CtorDecls ] '}'
CtorDecls = name '(' [ CtorArgs ] ')' [ ',' CtorDecls ]
CtorArgs  = id ':' Type [ ',' CtorArgs ]
VarDecl   = ('var' | Type) id  '=' Exp ';'
FunDecl   = id '(' [ FArgs ] ')' [ '::' FunType ] '{' VarDecl* Stmt+ '}'
RetType   = Type
          | 'Void'
FunType   = [ FTypes ] '->' RetType
FTypes    = Type [ FTypes ]
Type      = BasicType
          | '(' Type ',' Type ')'
          | '[' Type ']'
          | id
          | name
BasicType = 'Int'
          | 'Bool'
          | 'Char'
FArgs     = [ FArgs ',' ] id
Stmt      = 'if' '(' Exp ')' '{' Stmt* '}' [ 'else' '{' Stmt* '}' ]
          | 'while' '(' Exp ')' '{' Stmt* '}'
          | id Field '=' Exp ';'
          | FunCall ';'
          | 'return' [ Exp ] ';'
Exp       = id Field
          | Exp Op2 Exp
          | Op1 Exp
          | int
          | char
          | 'False' | 'True'
          | '(' Exp ')'
          | FunCall
          | CtorCall
          | '[]'
          | '(' Exp ',' Exp ')'
Field     = [ Field ( '.' 'hd' | '.' 'tl' | '.' 'fst' | '.' 'snd' | '.' id ) ]
FunCall   = id '(' [ ActArgs ] ')'
CtorCall  = name '(' [ ActArgs ] ')'
ActArgs   = Exp [ ',' ActArgs ]
Op2       = '+'  | '-' | '*' | '/'  | '%'
          | '==' | '<' | '>' | '<=' | '>=' | '!='
          | '&&' | '||'
          | ':'
Op1       = '!'  | '-'
int       = [ '-' ] digit+
id        = alpha ( '_' | alphaNum)*
\end{verbatim}


\end{document}
